<!DOCTYPE html>
<html>
<head>
    <title>AutoNesting Pro</title>
    <meta charset="UTF-8">
    <style>
        :root {
            --primary: #2196F3;
            --background: #f5f5f5;
        }

        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: var(--background);
        }

        .drop-zone {
            border: 3px dashed var(--primary);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 30px 0;
            cursor: pointer;
            background: white;
            transition: 0.3s;
        }

        .drop-zone.dragover {
            background: #E3F2FD;
            border-color: #1976D2;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        input[type="number"] {
            padding: 8px;
            margin: 0 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 120px;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }

        button:hover {
            background: #1976D2;
        }

        .error {
            color: #D32F2F;
            padding: 15px;
            background: #FFEBEE;
            border-radius: 5px;
            margin: 15px 0;
            display: none;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        canvas {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
        }

        .stats {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <h1>AutoNesting Pro</h1>

    <div class="drop-zone" id="dropZone">
        <p>Перетащите DXF файл сюда или кликните для выбора</p>
        <input type="file" id="fileInput" accept=".dxf" hidden>
    </div>

    <div class="controls">
        <label>Размер листа (мм):</label>
        <input type="number" id="sheetWidth" value="2000" min="100" step="10">
        <input type="number" id="sheetHeight" value="3000" min="100" step="10">
        <button onclick="startNesting()">Начать раскладку</button>
    </div>

    <div class="error" id="errorContainer"></div>
    <div class="stats" id="stats"></div>
    <div class="canvas-container" id="results"></div>

    <script src="https://cdn.jsdelivr.net/npm/dxf-parser@1.0.0/dist/dxf-parser.min.js"></script>
    <script>
        const parser = new DxfParser();
        let parts = [];
        let worker;

        // Инициализация Web Worker
        function initWorker() {
            if (worker) return;
            
            const workerBlob = new Blob([`
                self.importScripts('https://cdn.jsdelivr.net/npm/compromise@13.11.2/builds/compromise.min.js');
                
                self.onmessage = function(e) {
                    const { parts, sheet, options } = e.data;
                    
                    try {
                        const result = performNesting(parts, sheet, options);
                        self.postMessage(result);
                    } catch (err) {
                        self.postMessage({ error: err.message });
                    }
                };

                function performNesting(parts, sheet, options) {
                    const sheets = [];
                    let remaining = [...parts];
                    let attempt = 0;
                    
                    while (remaining.length > 0 && attempt++ < 100) {
                        const sheetResult = { items: [], bounds: { width: sheet.width, height: sheet.height } };
                        let currentY = 0;
                        
                        remaining = remaining.filter(part => {
                            for (let rot of options.rotations) {
                                const rotated = rotatePart(part, rot);
                                if (tryPlace(rotated, sheetResult, currentY)) {
                                    sheetResult.items.push({ ...rotated, rotation: rot });
                                    currentY += rotated.height;
                                    return false;
                                }
                            }
                            return true;
                        });
                        
                        if (sheetResult.items.length === 0) break;
                        sheets.push(sheetResult);
                    }
                    
                    if (remaining.length > 0) throw new Error(\`Не удалось разместить \${remaining.length} деталей\`);
                    
                    return { 
                        sheets,
                        utilization: calculateUtilization(sheets, sheet)
                    };
                }

                function rotatePart(part, degrees) {
                    const radians = degrees * Math.PI / 180;
                    const cos = Math.cos(radians);
                    const sin = Math.sin(radians);
                    
                    return {
                        ...part,
                        points: part.points.map(p => ({
                            x: p.x * cos - p.y * sin,
                            y: p.x * sin + p.y * cos
                        })),
                        width: degrees % 180 === 0 ? part.width : part.height,
                        height: degrees % 180 === 0 ? part.height : part.width
                    };
                }

                function tryPlace(part, sheet, currentY) {
                    return (part.width <= sheet.bounds.width) && 
                           (currentY + part.height <= sheet.bounds.height);
                }

                function calculateUtilization(sheets, sheet) {
                    const totalArea = sheets.length * sheet.width * sheet.height;
                    const usedArea = sheets.reduce((sum, s) => 
                        sum + s.items.reduce((a, b) => a + b.width * b.height, 0), 0);
                    return (usedArea / totalArea) * 100;
                }
            `], { type: 'text/javascript' });
            
            worker = new Worker(URL.createObjectURL(workerBlob));
        }

        // Обработчики событий
        document.getElementById('dropZone').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) await processDXF(file);
        });

        ['dragover', 'dragenter'].forEach(event => {
            document.getElementById('dropZone').addEventListener(event, e => {
                e.preventDefault();
                e.target.classList.add('dragover');
            });
        });

        ['dragleave', 'drop'].forEach(event => {
            document.getElementById('dropZone').addEventListener(event, e => {
                e.preventDefault();
                e.target.classList.remove('dragover');
            });
        });

        document.getElementById('dropZone').addEventListener('drop', async e => {
            const file = e.dataTransfer.files[0];
            if (file) await processDXF(file);
        });

        // Основные функции
        async function processDXF(file) {
            try {
                const text = await file.text();
                const parsed = parser.parseSync(text);
                parts = extractParts(parsed);
                showPreview();
            } catch (err) {
                showError(\`Ошибка загрузки файла: \${err.message}\`);
            }
        }

        function extractParts(data) {
            return data.entities
                .filter(e => e.type === 'LWPOLYLINE')
                .map(entity => ({
                    points: entity.vertices.map(v => ({ x: v.x, y: v.y })),
                    width: entity.bounds.max.x - entity.bounds.min.x,
                    height: entity.bounds.max.y - entity.bounds.min.y
                }));
        }

        function startNesting() {
            initWorker();
            clearResults();
            
            const sheet = {
                width: parseInt(document.getElementById('sheetWidth').value),
                height: parseInt(document.getElementById('sheetHeight').value)
            };

            if (!validateSheetSize(sheet)) return;

            worker.onmessage = e => {
                if (e.data.error) showError(e.data.error);
                else renderResults(e.data);
            };

            worker.postMessage({
                parts: parts,
                sheet: sheet,
                options: { rotations: [0, 90, 180, 270] }
            });
        }

        function validateSheetSize(sheet) {
            const maxPartSize = parts.reduce((max, part) => 
                Math.max(max, part.width, part.height), 0);
            
            if (maxPartSize > Math.max(sheet.width, sheet.height)) {
                showError('Некоторые детали превышают размер листа!');
                return false;
            }
            return true;
        }

        function renderResults(result) {
            document.getElementById('stats').innerHTML = \`
                Листов: \${result.sheets.length} | 
                Использование материала: \${result.utilization.toFixed(1)}%
            \`;

            result.sheets.forEach((sheet, index) => {
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 300;
                
                const ctx = canvas.getContext('2d');
                drawSheet(ctx, sheet, index);
                
                document.getElementById('results').appendChild(canvas);
            });
        }

        function drawSheet(ctx, sheet, index) {
            const scaleX = 380 / sheet.bounds.width;
            const scaleY = 280 / sheet.bounds.height;
            const scale = Math.min(scaleX, scaleY);

            ctx.strokeStyle = '#333';
            ctx.strokeRect(10, 10, 380, 280);

            sheet.items.forEach(item => {
                ctx.fillStyle = \`hsl(\${Math.random() * 360}, 50%, 80%)\`;
                ctx.beginPath();
                
                item.points.forEach((p, i) => {
                    const x = 10 + (p.x - item.points[0].x + item.x) * scale;
                    const y = 10 + (p.y - item.points[0].y + item.y) * scale;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.closePath();
                ctx.fill();
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorContainer');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('stats').innerHTML = '';
        }

        function showPreview() {
            document.getElementById('stats').innerHTML = \`
                Загружено \${parts.length} деталей | 
                Макс. размер: \${Math.max(...parts.map(p => Math.max(p.width, p.height))).toFixed(1)} мм
            \`;
        }
    </script>
</body>
</html>